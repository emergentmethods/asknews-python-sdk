from __future__ import annotations

from datetime import datetime, timezone
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import AfterValidator, BaseModel, ConfigDict, Field, HttpUrl, RootModel
from typing_extensions import Annotated

from asknews_sdk.dto.base import BaseSchema
from asknews_sdk.dto.news import SearchResponseDictItem


class CreateChatCompletionRequestMessage(BaseModel):
    role: Annotated[str, Field(title="Role")]
    content: Annotated[str, Field(title="Content")]
    name: Annotated[Optional[str], Field(None, title="Name")]
    function_call: Annotated[Optional[Dict[str, Any]], Field(None, title="Function Call")]


class CreateChatCompletionResponseChoice(BaseModel):
    index: Annotated[int, Field(title="Index")]
    message: CreateChatCompletionRequestMessage
    finish_reason: Annotated[Optional[str], Field(None, title="Finish Reason")]


class CreateChatCompletionResponseStreamChoice(BaseModel):
    index: Annotated[int, Field(title="Index")]
    delta: CreateChatCompletionRequestMessage
    finish_reason: Annotated[Optional[str], Field(None, title="Finish Reason")]


class CreateChatCompletionResponseUsage(BaseModel):
    prompt_tokens: Annotated[int, Field(title="Prompt Tokens")]
    completion_tokens: Annotated[int, Field(title="Completion Tokens")]
    total_tokens: Annotated[int, Field(title="Total Tokens")]


class CreateChatCompletionRequest(BaseSchema):
    model_config = ConfigDict(
        extra="allow",
    )
    model: Annotated[Optional[str], Field("gpt-3.5-turbo-16k", title="Model")]
    messages: Annotated[List[CreateChatCompletionRequestMessage], Field(title="Messages")]
    temperature: Annotated[Optional[float], Field(title="Temperature")] = 0.9
    top_p: Annotated[Optional[float], Field(title="Top P")] = 1.0
    n: Annotated[Optional[int], Field(title="N")] = 1
    stream: Annotated[Optional[bool], Field(title="Stream")] = False
    stop: Annotated[Optional[Union[str, List[str]]], Field(title="Stop")] = None
    max_tokens: Annotated[Optional[int], Field(title="Max Tokens")] = 9999
    presence_penalty: Annotated[Optional[int], Field(title="Presence Penalty")] = 0
    frequency_penalty: Annotated[Optional[int], Field(title="Frequency Penalty")] = 0
    user: Annotated[Optional[str], Field(title="User")] = None
    inline_citations: Annotated[
        Optional[Literal["markdown_link", "numbered", "none"]],
        Field("markdown_link", title="Type of inline citation formatting."),
    ]
    journalist_mode: Annotated[
        Optional[bool],
        Field(
            title=(
                "Activate journalist mode, with improved alignment for making claims"
                "with supporting evidence. Improved journalistic style."
            ),
        ),
    ] = True
    asknews_watermark: Annotated[
        Optional[bool], Field(title='Append "Generated by AskNews AI" watermark')
    ] = True
    append_references: Annotated[Optional[bool], Field(title="Append References or not")] = True
    conversational_awareness: Annotated[Optional[bool], Field(title="Conversational Awareness")] = (
        False
    )
    filter_params: Annotated[
        Optional[Dict[str, Any]],
        Field(title="Any filter param available on the /news endpoint."),
    ] = None


class CreateChatCompletionResponse(BaseSchema):
    id: Annotated[str, Field(title="Id")]
    created: Annotated[int, Field(title="Created")]
    object: Annotated[Optional[str], Field("chat.completion", title="Object")]
    model: Annotated[Optional[str], Field("gpt-3.5-turbo-16k", title="Model")]
    usage: CreateChatCompletionResponseUsage
    choices: Annotated[List[CreateChatCompletionResponseChoice], Field(title="Choices")]


class CreateChatCompletionResponseStream(BaseSchema):
    __content_type__ = "text/event-stream"

    id: Annotated[str, Field(title="Id")]
    created: Annotated[int, Field(title="Created")]
    object: Annotated[Optional[str], Field("chat.completion.chunk", title="Object")]
    model: Annotated[Optional[str], Field("gpt-3.5-turbo-16k", title="Model")]
    usage: CreateChatCompletionResponseUsage
    choices: Annotated[List[CreateChatCompletionResponseStreamChoice], Field(title="Choices")]


class CreateChatCompletionResponseStreamErrorDetails(BaseModel):
    message: Annotated[str, Field(title="Message")]
    code: Annotated[int, Field(title="Code")]


class CreateChatCompletionResponseStreamError(BaseSchema):
    __content_type__ = "text/event-stream"

    error: Annotated[CreateChatCompletionResponseStreamErrorDetails, Field(title="Error")]


class ModelItem(BaseModel):
    id: Annotated[str, Field(title="Id")]
    object: Annotated[Optional[str], Field("model", title="Object")]
    created: Annotated[
        Optional[int],
        Field(
            default_factory=lambda: int(datetime.now(timezone.utc).timestamp()),
            title="Created",
        ),
    ]
    owned_by: Annotated[Optional[str], Field("asknews", title="Owned By")]


class ListModelResponse(BaseSchema):
    __content_type__ = "application/json"

    object: Annotated[Optional[str], Field("list", title="Object")]
    data: Annotated[List[ModelItem], Field(title="Data")]


class HeadlineQuestionsResponse(BaseSchema, RootModel[Dict[str, List[str]]]): ...


HttpUrlString = Annotated[HttpUrl, AfterValidator(lambda v: str(v))]


class KeyPerson(BaseModel):
    name: str
    role: str


class WebSearchResult(BaseModel):
    title: str
    url: HttpUrlString
    source: str
    published: str
    key_points: List[str]
    raw_text: str = ""
    as_string_key: Optional[str] = None


class WebSearchResponse(BaseModel):
    as_string: str
    as_dicts: List[WebSearchResult]
    offset: Optional[Union[int, str]] = None


class ForecastResponse(BaseModel):
    forecast: str
    resolution_criteria: str
    date: datetime
    reasoning: str
    sources: List[SearchResponseDictItem]
    timeline: List[str]
    opposite_request: str
    confidence: float
    choice: Union[bool, str]
    llm_confidence: int
    model_used: str
    likelihood: str
    probability: int
    web_search_results: List[WebSearchResult]
    summary: str
    key_people: List[KeyPerson]
    key_facets: List[str]
    reconciled_information: str
    candidate_models: List[str]
    unique_information: str
    expert_information: Dict


class FilterParams(BaseModel):
    query: Annotated[
        str,
        "Query string that can be any phrase, "
        "keyword, question, or paragraph. The more descriptive the better. "
        "Treat this like a powerful google query. This is optional.",
    ] = ""
    categories: Annotated[
        List[
            Literal[
                "All",
                "Business",
                "Crime",
                "Politics",
                "Science",
                "Sports",
                "Technology",
                "Military",
                "Health",
                "Entertainment",
                "Finance",
                "Culture",
                "Climate",
                "Environment",
                "World",
            ]
        ],
        "Categories of news to filter on",
    ] = ["All"]
    reporting_voice: Annotated[
        List[
            Literal[
                "Objective",
                "Subjective",
                "Investigative",
                "Narrative",
                "Analytical",
                "Advocacy",
                "Conversational",
                "Satirical",
                "Emotive",
                "Explanatory",
                "Persuasive",
                "Sensational",
                "Unknown",
                "all",
            ]
        ],
        "Type of reporting voice to filer by.",
    ] = ["all"]
    strategy: Annotated[
        Literal["latest news", "news knowledge", "default"],
        "Strategy to use for searching. 'latest news' automatically sets"
        "method='nl', historical=False, and looks within the past 24 hours. "
        "'news knowledge' automatically sets method='kw', historical=True, and looks"
        " within the past 60 days. 'news knowledge' will increase latency due to the "
        " larger search space in the archive. Use 'default' if you want to control "
        " start_timestamp, end_timestamp, historical, and method.",
    ] = "default"
    hours_back: Annotated[
        int,
        "Can be set to easily control the look back on the search. "
        "This is the same as controlling the 'start_timestamp' parameter. "
        "The difference is that this is not a timestamp, it is the number of hours "
        "back to look from the current time. Defaults to 24 hours.",
    ] = 24
    string_guarantee: Annotated[
        Optional[List[str]],
        "If defined, the search will only occur on articles "
        "that contain strings in this list. This is powerful for "
        "constraining important names or concepts. It is optional.",
    ] = None
    string_guarantee_op: Annotated[
        Literal["AND", "OR"],
        "Operator to use for string guarantee list. AND means all string_guarantee "
        "items must be present in all articles. OR means at least one of the items must "
        "be present.",
    ] = "AND"
    reverse_string_guarantee: Annotated[
        Optional[List[str]],
        "If defined, the search will only occur on articles "
        "that do not contain strings in this list. This is powerful "
        "for avoiding articles with a particular name or concept. It is optional.",
    ] = None
    entity_guarantee: Annotated[
        Optional[List[str]],
        "Entities that must be present in the retrieved articles. This is a list of strings, "
        "where each string includes entity type and entity value separated by a "
        "colon. The first element is the entity type and the second element is "
        "the entity value. For example ['Location:Paris', 'Person:John']. "
        "Allowed entity types include: Location, Person, Organization, Product, Technology",
    ] = None
    entity_guarantee_op: Annotated[
        Literal["AND", "OR"],
        "Operator to use for entity guarantee list. AND means all entity_guarantee "
        "items must be present in all articles. OR means at least one of the items "
        "must be present.",
    ] = "OR"
    countries: Annotated[
        Optional[List[str]],
        "Article source countries to filter by, this is the two-letter ISO country code"
        "For example: United States is 'US', France is 'FR', Sweden is 'SE'.",
    ] = None
    continents: Annotated[
        Optional[
            List[
                Literal[
                    "Africa",
                    "Asia",
                    "Oceania",
                    "Europe",
                    "Middle East",
                    "North America",
                    "South America",
                ]
            ]
        ],
        "The articles must be geographically focused on this continent.",
    ] = None
    sentiment: Annotated[
        Optional[Literal["negative", "neutral", "positive"]], "Sentiment to filter articles by."
    ] = None
    start_timestamp: Annotated[
        Optional[int],
        "Start timestamp to filter articles by. This is the earliest time "
        "to look for articles. This is a datetime object.",
    ] = None
    end_timestamp: Annotated[
        Optional[int],
        "End timestamp to filter articles by. This is the latest time "
        "to look for articles. This is a datetime object.",
    ] = None
    time_filter: Annotated[
        Optional[Literal["pub_date", "crawl_date"]],
        "Time filter to use for filtering articles. 'pub_date' is the "
        "published date of the article. 'created_at' is the date the article "
        "was created in the database.",
    ] = "crawl_date"


class FilterParamsMetadata(BaseModel):
    title: str


class FilterParamsResponse(BaseModel):
    metadata: FilterParamsMetadata
    filter_params: FilterParams


class SeriesConfig(BaseModel):
    name: str
    start_datetime: datetime
    end_datetime: datetime
    sampling: Optional[str] = "1d"
    time_filter: Optional[str] = "pub_date"
    categories: Optional[List[str]] = None
    domains: Optional[List[str]] = None
    bad_domain_url: Optional[List[str]] = None
    page_rank: Optional[int] = None
    string_guarantee: Optional[List[str]] = None
    string_guarantee_op: Optional[str] = "OR"
    reverse_string_guarantee: Optional[List[str]] = None
    entity_guarantee: Optional[List[str]] = None
    entity_guarantee_op: Optional[str] = "OR"
    countries: Optional[List[str]] = None
    countries_blacklist: Optional[List[str]] = None
    continents: Optional[List[str]] = None
    languages: Optional[List[str]] = None
    sentiment: Optional[str] = None
    reporting_voice: Optional[List[str]] = None
    provocative: Optional[str] = "all"


class ChartParameters(BaseModel):
    chart_type: Literal["line", "bar", "bar_pct"] = Field(
        ..., description="The type of chart to create"
    )
    title: Optional[str] = Field(None, description="The title of the chart")
    series: List[SeriesConfig] = Field(..., description="The series configurations for the chart")


class CreateChartRequest(BaseSchema):
    query: str = Field(..., description="The chart query to create")


class ChartResponse(BaseSchema):
    success: bool
    chart_json: Annotated[
        dict, Field(description="The plotly fig.to_json() JSON representation of the chart")
    ]
    query: str = None
    reasoning: Optional[str] = None
    parameters: Optional[ChartParameters] = None
    context: Optional[dict] = None
    iterations_used: Optional[int] = None
    last_reasoning: Optional[str] = None
    last_parameters: Optional[ChartParameters] = None
    png_data: Optional[str] = Field(None, description="Base64-encoded PNG image data of the chart")
    png_url: Optional[str] = Field(None, description="URL to the PNG image of the chart")
    chart_url: Optional[str] = Field(None, description="URL to the chart JSON object in S3")
